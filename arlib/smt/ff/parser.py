"""
Parse a finite field SMT-LIB input and solve using Z3.
TODO: generated by LLM. To be checked and refactored.
"""
from z3 import *
import re
from dataclasses import dataclass
from typing import Dict, Any, List, Union
import logging

@dataclass
class SMTContext:
    solver: Solver
    variables: Dict[str, Any]
    sorts: Dict[str, Any]
    field_size: int = None
    
class SMTParser:
    def __init__(self):
        self.ctx = SMTContext(
            solver=Solver(),
            variables={},
            sorts={},
        )
        
    def tokenize(self, text: str) -> List[str]:
        """Tokenize SMT-LIB input."""
        # Remove comments
        text = re.sub(';.*\n', '\n', text)
        # Add spaces around parentheses
        text = text.replace('(', ' ( ').replace(')', ' ) ')
        # Split into tokens
        return [token for token in text.split() if token.strip()]
    
    def parse_sexp(self, tokens: List[str]) -> List:
        """Parse s-expressions into nested lists."""
        if not tokens:
            return []
            
        token = tokens.pop(0)
        if token == '(':
            lst = []
            while tokens and tokens[0] != ')':
                lst.append(self.parse_sexp(tokens))
            tokens.pop(0)  # Remove ')'
            return lst
        elif token == ')':
            raise SyntaxError("Unexpected closing parenthesis")
        else:
            return token
            
    def create_finite_field_sort(self, size: int) -> BitVecSort:
        """Create a finite field sort of given size."""
        # Calculate minimum bits needed to represent field elements
        bits = (size - 1).bit_length()
        return BitVecSort(bits)
    
    def create_field_var(self, name: str, sort: BitVecSort) -> BitVec:
        """Create a finite field variable."""
        var = BitVec(name, sort.size())
        # Add constraint that var must be less than field size
        self.ctx.solver.add(ULT(var, BitVecVal(self.ctx.field_size, sort.size())))
        return var
    
    def handle_define_sort(self, command: List):
        """Handle define-sort command."""
        _, sort_name, _, field_spec = command
        if isinstance(field_spec, list) and field_spec[0] == '_' and field_spec[1] == 'FiniteField':
            self.ctx.field_size = int(field_spec[2])
            self.ctx.sorts[sort_name] = self.create_finite_field_sort(self.ctx.field_size)
    
    def handle_declare_fun(self, command: List):
        """Handle declare-fun command."""
        _, var_name, args, sort = command
        if not args:  # Currently only supporting nullary functions
            if sort in self.ctx.sorts:
                self.ctx.variables[var_name] = self.create_field_var(var_name, self.ctx.sorts[sort])
            elif sort == 'Bool':
                self.ctx.variables[var_name] = Bool(var_name)
    
    def evaluate_expr(self, expr, let_bindings=None) -> Any:
        """Evaluate an SMT expression."""
        if let_bindings is None:
            let_bindings = {}
            
        if isinstance(expr, str):
            if expr in let_bindings:
                return let_bindings[expr]
            if expr in self.ctx.variables:
                return self.ctx.variables[expr]
            if expr in ['true', 'false']:
                return expr == 'true'
            try:
                return int(expr)
            except ValueError:
                return expr
                
        if not isinstance(expr, list):
            return expr
            
        op = expr[0]
        
        if op == 'let':
            # Handle let bindings
            new_bindings = dict(let_bindings)
            bindings = expr[1]
            for binding in bindings:
                var_name, value = binding
                new_bindings[var_name] = self.evaluate_expr(value, let_bindings)
            return self.evaluate_expr(expr[2], new_bindings)
            
        if op == 'ff.mul':
            # Handle finite field multiplication
            x = self.evaluate_expr(expr[1], let_bindings)
            y = self.evaluate_expr(expr[2], let_bindings)
            return URem(x * y, BitVecVal(self.ctx.field_size, x.size()))
            
        if op == 'ff.add':
            # Handle finite field addition
            x = self.evaluate_expr(expr[1], let_bindings)
            y = self.evaluate_expr(expr[2], let_bindings)
            return URem(x + y, BitVecVal(self.ctx.field_size, x.size()))
            
        if op == '=>':
            # Handle implication
            x = self.evaluate_expr(expr[1], let_bindings)
            y = self.evaluate_expr(expr[2], let_bindings)
            return Implies(x, y)
            
        if op in ['and', 'or', 'not', '=']:
            # Handle boolean operations
            args = [self.evaluate_expr(arg, let_bindings) for arg in expr[1:]]
            if op == 'and':
                return And(*args)
            elif op == 'or':
                return Or(*args)
            elif op == 'not':
                return Not(args[0])
            else:  # op == '='
                return args[0] == args[1]
                
        if op == 'ite':
            # Handle if-then-else
            cond = self.evaluate_expr(expr[1], let_bindings)
            then_expr = self.evaluate_expr(expr[2], let_bindings)
            else_expr = self.evaluate_expr(expr[3], let_bindings)
            return If(cond, then_expr, else_expr)
            
        if op == 'as':
            # Handle as expressions for field constants
            value = int(expr[1][2:])  # Remove 'ff' prefix
            sort = expr[2]
            return BitVecVal(value, self.ctx.sorts[sort].size())
            
        raise ValueError(f"Unsupported operation: {op}")
    
    def handle_assert(self, command: List):
        """Handle assert command."""
        assertion = self.evaluate_expr(command[1])
        self.ctx.solver.add(assertion)
    
    def parse_commands(self, commands: List):
        """Parse and handle SMT-LIB commands."""
        for command in commands:
            if not isinstance(command, list):
                continue
                
            cmd_type = command[0]
            if cmd_type == 'set-logic' or cmd_type == 'set-info':
                continue
            elif cmd_type == 'define-sort':
                self.handle_define_sort(command)
            elif cmd_type == 'declare-fun':
                self.handle_declare_fun(command)
            elif cmd_type == 'assert':
                self.handle_assert(command)
            elif cmd_type == 'check-sat':
                print("Solving...")
                print(self.ctx.solver)
                result = self.ctx.solver.check()
                return result
    
    def parse_smt(self, smt_input: str):
        """Parse SMT-LIB input and solve."""
        tokens = self.tokenize(smt_input)
        commands = []
        while tokens:
            commands.append(self.parse_sexp(tokens))
        return self.parse_commands(commands)
    


def demo():
    # FIXME: the following formula should be unsat, but the current code is
    #  not able to prove it.
    # Example usage
    # Taken from Yices2 regression tests
    smt_input_string = """
(set-info :smt-lib-version 2.6)
(set-logic QF_FFA)
(define-sort FF0 () (_ FiniteField 3))
(declare-fun x0 () FF0)
(declare-fun x1 () FF0)
(declare-fun x2 () FF0)
(declare-fun x3 () FF0)
(declare-fun x4 () FF0)
(declare-fun x5 () FF0)
(declare-fun x6 () FF0)
(declare-fun x7 () FF0)
(assert
  (let ((let0 (ff.mul x2 x2 x2)))
  (let ((let1 (ff.mul x0 x2 x3)))
  (let ((let2 (ff.mul x1 x4 x5)))
  (let ((let3 (ff.mul (as ff2 FF0) x0 x2 x6)))
  (let ((let4 (ff.mul (as ff2 FF0) x0 x5)))
  (let ((let5 (as ff1 FF0)))
  (let ((let6 (ff.add let0 let1 let2 let3 let4 let5)))
  (let ((let7 (= let6 (as ff0 FF0))))
  (let ((let8 (ff.mul (as ff2 FF0) x2 x4 x5)))
  (let ((let9 (ff.mul x2 x2 x6)))
  (let ((let10 (ff.mul (as ff2 FF0) x0 x1 x7)))
  (let ((let11 (ff.mul (as ff2 FF0) x2 x5 x7)))
  (let ((let12 (ff.mul x2 x7)))
  (let ((let13 (ff.add let8 let9 let10 let11 let12)))
  (let ((let14 (= let13 (as ff0 FF0))))
  (let ((let15 (ff.mul (as ff2 FF0) x6 x6 x6)))
  (let ((let16 (ff.mul (as ff2 FF0) x3 x7 x7)))
  (let ((let17 (ff.mul (as ff2 FF0) x1 x5)))
  (let ((let18 (ff.mul (as ff2 FF0) x1 x6)))
  (let ((let19 (ff.add let15 let16 let17 let18)))
  (let ((let20 (= let19 (as ff0 FF0))))
  (let ((let21 (ff.mul x2 x2 x5)))
  (let ((let22 (ff.mul x4 x7)))
  (let ((let23 (ff.add let21 let22)))
  (let ((let24 (= let23 (as ff0 FF0))))
  (let ((let25 (ff.mul x0 x0 x2)))
  (let ((let26 (= let25 (as ff0 FF0))))
  (let ((let27 (ff.mul (as ff2 FF0) x0 x3 x7)))
  (let ((let28 (ff.mul (as ff2 FF0) x2 x4 x7)))
  (let ((let29 (as ff2 FF0)))
  (let ((let30 (ff.add let27 let28 let29)))
  (let ((let31 (= let30 (as ff0 FF0))))
  (let ((let32 (ff.mul (as ff2 FF0) x1 x3 x4)))
  (let ((let33 (ff.mul (as ff2 FF0) x6 x6 x6)))
  (let ((let34 (ff.mul x2 x2)))
  (let ((let35 (ff.mul (as ff2 FF0) x4 x4)))
  (let ((let36 (ff.mul (as ff2 FF0) x4 x6)))
  (let ((let37 (ff.add let32 let33 let34 let35 let36)))
  (let ((let38 (= let37 (as ff0 FF0))))
  (let ((let39 (ff.mul (as ff2 FF0) x4 x5 x5)))
  (let ((let40 (ff.mul (as ff2 FF0) x1 x2 x6)))
  (let ((let41 (ff.mul x5 x6 x6)))
  (let ((let42 (ff.mul x0 x4)))
  (let ((let43 (ff.add let39 let40 let41 let42)))
  (let ((let44 (= let43 (as ff0 FF0))))
  (let ((let45 (and let7 let14 let20 let24 let26 let31 let38 let44)))
  let45
))))))))))))))))))))))))))))))))))))))))))))))
)
(check-sat)
    """
    parser = SMTParser()
    result = parser.parse_smt(smt_input_string)
    print(result)
    if result == sat:
        print(parser.ctx.solver.model())


if __name__ == '__main__':
    demo()