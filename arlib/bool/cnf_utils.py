# coding: utf-8
"""
Boolean Formula Manipulation Utilities

This module provides a comprehensive set of utilities for manipulating Boolean formulas,
with a focus on CNF (Conjunctive Normal Form) operations. Features include formula
transformation, simplification, analysis, and various CNF-specific operations.

TODO: generated by LLM, to be checked and complete
"""
from typing import List, Set, Dict, Tuple, Optional
from dataclasses import dataclass
from collections import defaultdict
import itertools


@dataclass
class CNFFormula:
    """Represents a formula in Conjunctive Normal Form"""
    clauses: List[Set[int]]
    num_vars: int

    @classmethod
    def from_list(cls, clauses: List[List[int]]) -> 'CNFFormula':
        """Create CNFFormula from nested list representation"""
        clause_sets = [set(clause) for clause in clauses]
        num_vars = max(abs(lit) for clause in clause_sets for lit in clause)
        return cls(clause_sets, num_vars)

    def to_list(self) -> List[List[int]]:
        """Convert to nested list representation"""
        return [list(clause) for clause in self.clauses]

    def __str__(self) -> str:
        """Human-readable representation"""
        return " ∧ ".join(f"({' ∨ '.join(map(str, sorted(clause)))})"
                          for clause in self.clauses)


class CNFUtils:
    """Collection of CNF formula manipulation utilities"""

    @staticmethod
    def simplify(formula: CNFFormula) -> CNFFormula:
        """
        Simplify a CNF formula by:
        - Removing duplicate clauses
        - Removing duplicate literals within clauses
        - Removing tautological clauses (containing both p and ¬p)
        - Removing subsumed clauses
        """
        # Remove tautological clauses and duplicate literals
        simplified_clauses = []
        for clause in formula.clauses:
            # Check for tautology
            if any(lit in clause and -lit in clause for lit in clause):
                continue
            # Remove duplicates while preserving order
            simplified_clauses.append(set(clause))

        # Remove duplicate clauses and subsumption
        final_clauses = []
        for i, clause1 in enumerate(simplified_clauses):
            is_subsumed = False
            for j, clause2 in enumerate(simplified_clauses):
                if i != j and clause2.issubset(clause1):
                    is_subsumed = True
                    break
            if not is_subsumed:
                final_clauses.append(clause1)

        return CNFFormula(final_clauses, formula.num_vars)

    @staticmethod
    def unit_propagation(formula: CNFFormula) -> Tuple[CNFFormula, Dict[int, bool]]:
        """
        Perform unit propagation on a CNF formula.
        Returns the simplified formula and the assignments made.
        """
        assignments = {}
        clauses = formula.clauses.copy()
        changed = True

        while changed:
            changed = False
            unit_clauses = [c for c in clauses if len(c) == 1]

            for clause in unit_clauses:
                unit_lit = next(iter(clause))  # Get the single literal
                var = abs(unit_lit)
                value = unit_lit > 0

                if var in assignments and assignments[var] != value:
                    # Contradiction found
                    return CNFFormula([set()], formula.num_vars), assignments

                assignments[var] = value

                # Simplify remaining clauses
                new_clauses = []
                for c in clauses:
                    if unit_lit in c:  # Clause is satisfied
                        continue
                    if -unit_lit in c:  # Remove false literal
                        new_c = c - {-unit_lit}
                        if not new_c:  # Empty clause - contradiction
                            return CNFFormula([set()], formula.num_vars), assignments
                        new_clauses.append(new_c)
                    else:
                        new_clauses.append(c)

                if clauses != new_clauses:
                    changed = True
                    clauses = new_clauses

        return CNFFormula(clauses, formula.num_vars), assignments

    @staticmethod
    def pure_literal_elimination(formula: CNFFormula) -> Tuple[CNFFormula, Set[int]]:
        """
        Eliminate pure literals from a CNF formula.
        A literal is pure if it only appears with one polarity.
        """
        # Collect all literals and their polarities
        literals = defaultdict(set)
        for clause in formula.clauses:
            for lit in clause:
                literals[abs(lit)].add(lit > 0)

        # Find pure literals
        pure_literals = {var if next(iter(polarities)) else -var
                         for var, polarities in literals.items()
                         if len(polarities) == 1}

        # Remove clauses containing pure literals
        new_clauses = [clause for clause in formula.clauses
                       if not any(lit in pure_literals for lit in clause)]

        return CNFFormula(new_clauses, formula.num_vars), pure_literals

    @staticmethod
    def resolve_clauses(clause1: Set[int], clause2: Set[int], pivot: int) -> Optional[Set[int]]:
        """
        Perform resolution between two clauses on a given pivot variable.
        Returns None if no resolution is possible.
        """
        if pivot not in clause1 or -pivot not in clause2:
            return None

        resolvent = (clause1 - {pivot}) | (clause2 - {-pivot})

        # Check for tautology
        if any(lit in resolvent and -lit in resolvent for lit in resolvent):
            return None

        return resolvent

    @staticmethod
    def variable_elimination(formula: CNFFormula, var: int) -> CNFFormula:
        """
        Eliminate a variable from the formula using resolution.
        This implements the Davis-Putnam procedure for a single variable.
        """
        pos_clauses = [c for c in formula.clauses if var in c]
        neg_clauses = [c for c in formula.clauses if -var in c]
        other_clauses = [c for c in formula.clauses if var not in c and -var not in c]

        # Generate resolvents
        new_clauses = other_clauses.copy()
        for pos_clause in pos_clauses:
            for neg_clause in neg_clauses:
                resolvent = CNFUtils.resolve_clauses(pos_clause, neg_clause, var)
                if resolvent is not None:
                    new_clauses.append(resolvent)

        return CNFFormula(new_clauses, formula.num_vars)

    @staticmethod
    def is_horn_formula(formula: CNFFormula) -> bool:
        """
        Check if the formula is a Horn formula.
        A Horn formula has at most one positive literal per clause.
        """
        return all(sum(1 for lit in clause if lit > 0) <= 1
                   for clause in formula.clauses)

    @staticmethod
    def is_2sat_formula(formula: CNFFormula) -> bool:
        """Check if the formula is in 2-SAT (all clauses have at most 2 literals)"""
        return all(len(clause) <= 2 for clause in formula.clauses)

    @staticmethod
    def get_formula_statistics(formula: CNFFormula) -> Dict[str, int]:
        """Compute various statistics about the formula"""
        return {
            'num_variables': formula.num_vars,
            'num_clauses': len(formula.clauses),
            'max_clause_size': max(len(c) for c in formula.clauses),
            'min_clause_size': min(len(c) for c in formula.clauses),
            'total_literals': sum(len(c) for c in formula.clauses),
            'unit_clauses': sum(1 for c in formula.clauses if len(c) == 1),
            'binary_clauses': sum(1 for c in formula.clauses if len(c) == 2),
            'horn_clauses': sum(1 for c in formula.clauses
                                if sum(1 for lit in c if lit > 0) <= 1)
        }


def run_cnf_tests():
    """Test cases for CNF utilities"""
    # Test case 1: Simple CNF formula
    formula1 = CNFFormula.from_list([[1, 2], [-1, 3], [-2, -3]])
    print(f"Original formula: {formula1}")

    # Test simplification
    simplified = CNFUtils.simplify(formula1)
    print(f"Simplified: {simplified}")

    # Test unit propagation
    formula2 = CNFFormula.from_list([[1], [1, 2], [-2, 3], [-1, -3]])
    prop_result, assignments = CNFUtils.unit_propagation(formula2)
    print(f"\nUnit propagation result: {prop_result}")
    print(f"Assignments: {assignments}")

    # Test pure literal elimination
    formula3 = CNFFormula.from_list([[1, 2], [1, 3], [2, 3]])
    elim_result, pure_lits = CNFUtils.pure_literal_elimination(formula3)
    print(f"\nPure literal elimination result: {elim_result}")
    print(f"Pure literals: {pure_lits}")

    # Test formula statistics
    stats = CNFUtils.get_formula_statistics(formula1)
    print("\nFormula statistics:")
    for key, value in stats.items():
        print(f"{key}: {value}")


if __name__ == "__main__":
    run_cnf_tests()