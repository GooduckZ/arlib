"""
MCMC Sampling for Solutions of SMT formulas
TODO: generated by LLM, to be checked
"""

from z3 import *
import random


class MCMCSampler:
    def __init__(self, formula, num_samples=10, burn_in=100, step_size=0.1):
        self.formula = formula
        self.num_samples = num_samples
        self.burn_in = burn_in
        self.step_size = step_size
        self.solver = Solver()
        self.solver.add(formula)

    def sample(self):
        if self.solver.check() != sat:
            raise ValueError("Formula is unsatisfiable")

        samples = []
        unique_samples = set()
        current_sample = self._random_initial_sample()

        for _ in range(self.burn_in + self.num_samples):
            next_sample = self._propose_next_sample(current_sample)
            if self._accept_sample(next_sample):
                current_sample = next_sample
            if _ >= self.burn_in:
                sample_tuple = tuple(current_sample.items())
                if sample_tuple not in unique_samples:
                    unique_samples.add(sample_tuple)
                    samples.append(current_sample)

        return samples

    def _random_initial_sample(self):
        model = self.solver.model()
        return {d: model[d] for d in model.decls()}

    def _propose_next_sample(self, current_sample):
        next_sample = {}
        for var, value in current_sample.items():
            if isinstance(value, RatNumRef):
                numerator = value.numerator_as_long()
                denominator = value.denominator_as_long()
                new_numerator = numerator + random.randint(-1, 1)
                next_sample[var] = RatNumRef(new_numerator, denominator)
            elif isinstance(value, AlgebraicNumRef):
                # Skip AlgebraicNumRef values as they are not supported
                next_sample[var] = value
            else:
                next_sample[var] = value + (random.random() - 0.5) * 2 * self.step_size
        return next_sample

    def _accept_sample(self, sample):
        self.solver.push()
        for var, value in sample.items():
            self.solver.add(var == value)
        is_accepted = self.solver.check() == sat
        self.solver.pop()
        return is_accepted


if __name__ == "__main__":
    # Example usage
    x, y = Reals('x y')
    formula = And(x ** 2 + y ** 2 < 1, x > 0, y > 0)

    try:
        sampler = MCMCSampler(formula, num_samples=10, burn_in=100, step_size=0.1)
        samples = sampler.sample()
        for i, sample in enumerate(samples, start=1):
            print(f"Sample {i}: {sample}")
    except ValueError as e:
        print(f"Error: {str(e)}")
